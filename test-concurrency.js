/**
 * GENERATED BY AI
 * Concurrency Test for TicketBoss API
 * This script simulates multiple partners trying to reserve seats simultaneously
 */

const BASE_URL = "http://localhost:3000";

const reserveSeats = async (partnerId, seats) => {
  const start = Date.now();
  try {
    const res = await fetch(`${BASE_URL}/reservations`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ partnerId, seats }),
    });
    const data = await res.json();
    const duration = Date.now() - start;
    return { partnerId, status: res.status, data, duration };
  } catch (error) {
    return { partnerId, status: "error", error: error.message };
  }
};

const getEventSummary = async () => {
  const res = await fetch(`${BASE_URL}/reservations`);
  return res.json();
};

const runConcurrencyTest = async () => {
  console.log("=".repeat(60));
  console.log("CONCURRENCY TEST - TicketBoss API");
  console.log("=".repeat(60));

  // Get initial state
  const before = await getEventSummary();
  console.log("\n[BEFORE] Event State:");
  console.log(`  Available Seats: ${before.availableSeats}`);
  console.log(`  Version: ${before.version}`);
  console.log(`  Reservations: ${before.reservationCount}`);

  // Simulate 10 partners trying to reserve 10 seats each (100 total)
  // If all succeed, it would need 100 seats
  const numPartners = 10;
  const seatsPerPartner = 10;

  console.log(`\n[TEST] Firing ${numPartners} concurrent requests...`);
  console.log(`  Each partner requesting ${seatsPerPartner} seats`);
  console.log(`  Total seats requested: ${numPartners * seatsPerPartner}`);

  // Fire all requests simultaneously
  const startTime = Date.now();
  const promises = [];
  for (let i = 1; i <= numPartners; i++) {
    promises.push(reserveSeats(`partner-${i}`, seatsPerPartner));
  }

  const results = await Promise.all(promises);
  const totalTime = Date.now() - startTime;

  // Analyze results
  const successful = results.filter((r) => r.status === 201);
  const conflicts = results.filter((r) => r.status === 409);
  const errors = results.filter((r) => r.status !== 201 && r.status !== 409);

  console.log(`\n[RESULTS] Completed in ${totalTime}ms`);
  console.log(`  Successful (201): ${successful.length}`);
  console.log(`  Conflicts (409): ${conflicts.length}`);
  console.log(`  Errors: ${errors.length}`);

  // Show individual results
  console.log("\n[DETAILS] Individual Responses:");
  results.forEach((r) => {
    const status = r.status === 201 ? "✓ CONFIRMED" : "✗ CONFLICT";
    console.log(`  ${r.partnerId}: ${status} (${r.duration}ms)`);
  });

  // Get final state
  const after = await getEventSummary();
  console.log("\n[AFTER] Event State:");
  console.log(`  Available Seats: ${after.availableSeats}`);
  console.log(`  Version: ${after.version}`);
  console.log(`  Reservations: ${after.reservationCount}`);

  // Verify no overselling
  const seatsReserved = before.availableSeats - after.availableSeats;
  const expectedSeats = successful.length * seatsPerPartner;

  console.log("\n[VERIFICATION]");
  console.log(`  Seats actually reserved: ${seatsReserved}`);
  console.log(`  Expected from successful: ${expectedSeats}`);

  if (seatsReserved === expectedSeats && after.availableSeats >= 0) {
    console.log("\n✅ PASS: No overselling occurred! OCC is working correctly.");
  } else {
    console.log("\n❌ FAIL: Inconsistency detected!");
  }

  console.log("\n" + "=".repeat(60));
};

// Run test
runConcurrencyTest().catch(console.error);